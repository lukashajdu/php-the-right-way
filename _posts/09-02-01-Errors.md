---
title: Chyby
isChild: true
anchor: errors
---

## Chyby {#errors_title}

V mnohých programovacích jazykoch "tvrdo založených na výnimkách" je výnimka vyvolaná, kedykoľvek nastane nejaká chyba.
Toto je určite schopný spôsob spracovania, ale PHP je programovací jazyk "ľahko založený na výnimkách". I napriek tomu, že PHP
podporuje výnimky a stále viac základných funkcií, pokiaľ sa jedná o objekty, ich začína použivať, väčšina samotného PHP
sa snaží udržať chod programu bez ohľadu na to, čo sa deje, až pokiaľ nenastane fatálna chyba.

Napríklad:

{% highlight console %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

Kedže toto je len upozornenie, PHP bude bez problémov pokračovať. Toto môže byť mätúce pre tých prichádzajúcích
z jazykov "tvrdo založených na výnimkách", pretože napríklad referencia na chýbajúcu premennú v jazyku Python vyvolá
výnimku:

{% highlight console %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

Jediný skutočný rozdiel je, že Python bude šalieť za každú malú chybu, takže si vývojári môžu byť istý, že každá
potenciálna chyba, alebo hraničná situácia budú zachytené, kdežto PHP bude spracovávať kód, až kým  nestane niečo
extrémne. V tomto bode vyvolá a ohlási chybu.

### Závažnosť chýb

PHP má niekoľko úrovní závažnosti chýb. Tri najpoužívanejšie druhy chybových hlásení sú chyby (error), poznámky (notice)
a upozornenia (warning). Každé z týchto hlásení má rozdielnu úroveň závažnosti; `E_ERROR`, `E_NOTICE`, a `E_WARNING`.
Chyby sú fatálne omyly, ktoré môžu nastať počas chodu programu a sú obyčajne spôsobené nedostatkami v kóde.
Tieto nedostatky musia byť odstránené inak budú naďalej prerušovať beh programu. Poznámky sú pomocné správy spôsobené
nedostatkami v kóde, ktoré môžu, ale nemusia spôsobovať problémy počas behu programu. Beh programu s takouto chybou
nie je zastavený. Upozornenia sú nefatálne chyby, ktoré nespôsobujú zastavenie behu programu.

Ďalším druhom chybových hlásení počas kompilácie programu sú hlásenia pre úroveň `E_STRICT`. Tieto hlásenia navrhujú
pre váš kód zmeny, ktoré zabezpečia interoperabilitu a spätnú kompatibilitu s nadchádzajúcimi verziami PHP.

### Zmena priebehu hlásenia chýb v PHP

Hlásenie chýb môže byť zmenené pomocou nastavení v PHP, a/alebo pomocou funkčných volaní. Použitím vstavanej funkcie
`error_reporting()` môžete nastaviť úroveň chybových hlásení počas priebehu programu predaním jednej z preddefinovaných
konštánt. To znamená, že ak chcete napríklad vidieť len chyby a upozornenia, ale nie poznámky, potom môžete túto
úroveň zmeniť nasledovne:

{% highlight php %}
<?php
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

Pomocou nastavení môžete taktiež kontrolovať, či sa chyby majú, alebo nemajú zobraziť na obrazovke. Zobrazenie chýb
na obrazovke je dobré pre programátorov, kdežto nezobrazenie chýb na obrazovke ale ich ukladanie do súboru s chybovými
hláseniami je dobré pre produkčný kód. Pre viac informácií si pozrite sekciu [Hlásenie chýb][errorreport].

### Inline Error Suppression

You can also tell PHP to suppress specific errors with the Error Control Operator `@`. You put this operator at the
beginning of an expression, and any error that's a direct result of the expression is silenced.

{% highlight php %}
<?php
echo @$foo['bar'];
{% endhighlight %}

This will output `$foo['bar']` if it exists, but will simply return a null and print nothing if the variable `$foo` or
`'bar'` key does not exist. Without the error control operator, this expression could create a `PHP Notice: Undefined
variable: foo` or `PHP Notice: Undefined index: bar` error.

This might seem like a good idea, but there are a few undesirable tradeoffs. PHP handles expressions using an `@` in a
less performant way than expressions without an `@`. Premature optimization may be the root of all programming
arguments, but if performance is particularly important for your application/library it's important to understand the
error control operator's performance implications.

Secondly, the error control operator **completely** swallows the error. The error is not displayed, and the error is
not sent to the error log. Also, stock/production PHP systems have no way to turn off the error control operator. While
you may be correct that the error you're seeing is harmless, a different, less harmless error will be just as silent.

If there's a way to avoid the error suppression operator, you should consider it. For example, our code above could be
rewritten like this:

{% highlight php %}
<?php
echo isset($foo['bar']) ? $foo['bar'] : '';
{% endhighlight %}

One instance where error suppression might make sense is where `fopen()` fails to find a file to load. You could check
for the existence of the file before you try to load it, but if the file is deleted after the check and before the
`fopen()` (which might sound impossible, but it can happen) then `fopen()` will return false _and_ throw an error. This
is potentially something PHP should resolve, but is one case where error suppression might seem like the only valid
solution.

Earlier we mentioned there's no way in a stock PHP system to turn off the error control operator. However, [Xdebug] has
an `xdebug.scream` ini setting which will disable the error control operator. You can set this via your `php.ini` file
with the following.

{% highlight ini %}
xdebug.scream = On
{% endhighlight %}

You can also set this value at runtime with the `ini_set` function

{% highlight php %}
<?php
ini_set('xdebug.scream', '1')
{% endhighlight %}

The "[Scream]" PHP extension offers similar functionality to Xdebug's, although Scream's ini setting is named
`scream.enabled`.

This is most useful when you're debugging code and suspect an informative error is suppressed. Use scream with care,
and as a temporary debugging tool. There's lots of PHP library code that may not work with the error control operator
disabled.


* [Error Control Operators]
* [SitePoint]
* [Xdebug]
* [Scream]


### ErrorException

PHP is perfectly capable of being an "exception-heavy" programming language, and only requires a few lines of code to
make the switch. Basically you can throw your "errors" as "exceptions" using the `ErrorException` class, which extends
the `Exception` class.

This is a common practice implemented by a large number of modern frameworks such as Symfony and Laravel. By default
Laravel will display all errors as exceptions using the [Whoops!] package if the `app.debug` switch is turned on, then
hide them if the switch is turned off.

By throwing errors as exceptions in development you can handle them better than the usual result, and if you see an
exception during development you can wrap it in a catch statement with specific instructions on how to handle the
situation. Each exception you catch instantly makes your application that little bit more robust.

More information on this and details on how to use `ErrorException` with error handling can be found at
[ErrorException Class][errorexception].

* [Error Control Operators]
* [Predefined Constants for Error Handling]
* [`error_reporting()`][error_reporting]
* [Reporting][errorreport]


[errorreport]: /#error_reporting
[Xdebug]: http://xdebug.org/docs/basic
[Scream]: http://php.net/book.scream
[Error Control Operators]: http://php.net/language.operators.errorcontrol
[SitePoint]: http://www.sitepoint.com/
[Whoops!]: http://filp.github.io/whoops/
[errorexception]: http://php.net/class.errorexception
[Predefined Constants for Error Handling]: http://php.net/errorfunc.constants
[error_reporting]: http://php.net/function.error-reporting
